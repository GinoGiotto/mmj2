<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>EarleyTreeBuilder.html</title></head>
<body style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);" alink="#000088" link="#0000ff" vlink="#ff0000">
<h3><span style="font-weight: bold;">EarleyParseBuilder</span>


</h3>

<span style="font-weight: bold;">(derived from Dick Grune and Ceriel
J.H. Jacob's "Parsing Techniques -- A Practical Guide" -- my
compliments to the authors! See page 149 in Edition 1 -- which is the
139th page in the .pdf book file.)<br>
<br>
</span>
<hr style="width: 100%; height: 2px;">See also:<br>
<a href="EarleyParseFunctionAlgorithm.html">EarleyParseFunctionAlgorithm.html</a><br>

<a href="EarleyParseCompletedItemSetsExample.html">EarleyParseCompletedItemSetsExample.html</a><br>
<br>
<span style="font-weight: bold;">
</span>
<hr style="width: 100%; height: 2px;"><span style="font-weight: bold;"><big>Overview/Context:</big> </span>EarleyTreeBuilder creates one or more unique <code>ParseTree</code>s from the <code>pCompletedItem</code> Completed ItemSets generated by the <code>EarleyParser</code> function algorithm. <br>
<ul>
  <li>ParseTrees are returned to the calling function in <code>parseTreeArray</code>, whose length indicates the maximum number of <code>ParseTree</code>s desired. </li>
  <li>A <code>parseCnt</code> is returned to inform the caller whether 0, 1, ... or n <code>ParseTree</code>s were created. A <code>parseCnt</code> of zero indicates no parse was possible, while a <code>parseCnt</code> greater than one indicates an ambiguous parse since each output <code>ParseTree</code> is "guaranteed" to be different. </li>
  <li>For a <code>Grammar</code> that is known to be unambiguous, the fastest result may be obtained by specifying a <code>parseTreeArray</code> with length = 1. </li>
  <li>The
input expr is a rewritten version of the original parse Expression,
written as an array of ParseNodeHolder, with
the first symbol in expr[1]. This is done to simplify indexing by
coordinating with the Earley Parse numbering scheme. In addition the
EarleyParser has
"pre-parsed" certain symbols, including: Variable to corresponding
VariableHypothesis, and Cnst to matching "gimme" length 1 Constant
Syntax Axiom (AKA "Named, Typed Constant Syntax Axiom").</li>
  <li>There are <code>expr.length - 1</code> Completed ItemSets, one for each symbol in <code>expr</code>. Each Completed ItemSet, "<code>n</code>" contains <code>pCompletedItemSetCnt[n]</code> <code>EarleyItem</code>s. (each Completed ItemSet array may contain unused items at the end.)<br>
  </li>
  <li><code>expr</code>, <code>pCompletedItem</code> and <code>pCompletedItemSetCnt</code> have index values begin at <code>1</code> -- array position <code>0</code> is unused.Thus, <code>expr[1]</code> is the first symbol and <code>pCompletedItem[1]</code> is the first Completed ItemSet. These index values correspond to the <code>EarleyItem.atIndex</code> values: an <code>atIndex</code> value of <code>m</code> inside a Completed ItemSet<code>[n]</code> -- where <code>m &lt;= n</code> -- indicates that the <code>EarleyItem</code> has a <code>GrammarRule</code> matching symbols <code>m</code> through <code>n</code> in <code>expr</code>.</li><li>Start Rule Type is derived in <code>EarleyParser</code>
from the Formula's Type Code. For the purpose of tree building using
Earley Completed Item Sets, the Start Rule Type is the target and will
be the Type Code of the <code>Stmt</code> in the root of the <code>ParseTree</code>. In order to enable use of an arbitrary Start Rule Type, <code>EarleyParse</code> seeds Predictor(0) with all Type Codes that convert to the derived Start Rule Type. And, in <code>EarleyTreeBuilder</code>, accounting for the fact that a Start Rule Type might not have any <code>NotationRule</code>s
of its own, the search for a top level Rule includes Type Codes that
convert to the Start Rule; a tree whose root type is not the Start Rule
Type, but which does have a Type converting to the Start Type, will be
supplemented with a new root converting the tree's root to the Start
Type. As a practical matter, this has no effect on <code>set.mm</code>, but it might (somehow) be used with Type Codes that convert to "<code>wff</code>" (however, Type Codes that convert to the Provable Logic Stmt Type Code (i.e. "<code>|-</code>") are prohibited elsewhere via editing.)</li>

</ul>
<br>
<span style="font-weight: bold;"><br>
<big>Input:</big></span><br>
<ul>
  <li><span style="font-family: monospace;">Cnst &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; startRuleTyp;</span></li>
  <li><span style="font-family: monospace;">EarleyItem[][]&nbsp;&nbsp;&nbsp; pCompletedItem;</span></li>
  <li><span style="font-family: monospace;">int[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pCompletedItemSetCnt;</span></li>
  <li><span style="font-family: monospace;">ParseNodeHolder[] expr;</span></li>
  <li><span style="font-family: monospace;">Grammar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; grammar (for error messages)</span></li>
</ul>
<br>
<big><span style="font-weight: bold;">I/O:</span></big><br>
<ul>
  <li><span style="font-family: monospace;">ParseTree[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parseTreeArray;</span></li>
</ul>
<br>
<big><span style="font-weight: bold;">Output:</span></big><br>
<ul>
  <li><span style="font-family: monospace;">int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parseCnt (via return)</span></li>
  
</ul>
<br>
<hr style="width: 100%; height: 2px;"><br>
<big><span style="font-weight: bold;">Algorithm "Scheme"</span></big> <span style="font-weight: bold; font-style: italic;">(- 1) -- proposed and then revised</span>: <br>
<br>
<span style="font-weight: bold;">EarleyMapSet</span>: EarleyTreeBuilder
creates a mapping from the Earley Parse Completed Item Sets, Start Rule
Type and input expr to the corresponding Parse Tree(s). We will call
this mapping the Earley Map Set. It contains 0, 1 or more
EarleyRuleMaps.<br>
<br>
<br>
<small><code><big><span style="font-weight: bold;"></span></big></code></small><span style="font-weight: bold;">EarleyRuleMap</span>:&nbsp;
Each EarleyRuleMap corresponds ("maps to") a single ParseTree (or
sub-tree -- more on this below in "EarleyRuleMap Recursion". The unique
identifying key of an EarleyRuleMap is a GrammarRule and 'n', where n
is the nth position in the input expr. Thus, an EarleyRuleMap for an
input expr with n symbols and rule = XXXX, will have an EarleyItem in
pCompletedItemSet[n] with item.rule == XXXX and item.atIndex = 1. Given
a valid EarleyRuleMap we know that we can obtain hypotheses from the
input expression and feed them to the map's rule (XXXX(a,b,c), for
example), and recreate the input expression exactly -- if not, there is
a bug in the code somewhere!<br>
<br>
<br>
<span style="font-weight: bold;">EarleyRuleMap Twin Pointers</span>:
Because there can be more than one EarleyRuleMap in an EarleyMapSet, we
include twin pointer references, forward and backward in the
EarleyRuleMap object. This allows the data structure to accomodate an
arbitrary number of output ParseTrees, though of course multiple
ParseTrees indicate an Ambiguous Grammar! A given expression may have
0, 1 or many ParseTrees, with 0 indicating that the expression is
syntactically invalid (not part of the gramar), and more than 1
indicating ambiguity. Thus, the existence of a twin EarleyRuleMap
indicates ambiguity. During processing a global counter of the number
of twin EarleyRuleMaps is maintained, and this counter is used to limit
tree building as follows: if the user desires 'n' trees, then if Twin
Counter &gt;= Max Twins, no further processing to create twin
EarleyRuleMaps will be done.<br>
<br>
An interesting point about the EarleyRuleMap "twins": because each is
generated from a different Rule at the same item.atIndex position in
the input expr -- and the fact that EarleyParse prevents any duplicate
items in pCompletedItem[][] -- every output ParseTree is "guaranteed"
(subject to program bugs,) to be unique; there is no need to
mechanically check parseTree.isDup(), which was done in
BottomUpParse.java (that algorithm does generate duplicates.)<br>
<br>
<br>
<span style="font-weight: bold;">EarleyRuleMap ParseNodeHolder</span>:
in some cases, such as with an expression of length 1, there is not a
matching GramarRule, only a Variable Hypothesis statment that was
"pre-parsed" by EarleyParse. In these cases, a ParseNodeHolder is
stored in EarleyRuleMap instead of a Rule -- which is not a problem
because eventually each EarleyRuleMap is converted to a ParseNodeHolder
with a root ParseNode stored in the ParseNodeHolder. (This is the point
at which the present scheme varies from Grune's grammatical parsing --
we pre-parse variables plus NullsPermitted and TypeConversion
GrammarRules into the final set of NotationRules, so the input
expression contains only Cnst terminals and (pre)ParseNodes
representing Variable Hypotheses, Type Conversions, etc.)<br>
<br>
<br>
<span style="font-weight: bold;">EarleyRuleMap Recursion</span>: a
typical expression is built syntactically using a composite function of
multiple GrammarRules. A subsequence of an input expression may have
its own EarleyRuleMap, which will generate a hypothesis for the next
higher level rule in the ParseTree. Thus, the EarleyRuleMap has a
recursive structure.<br>
<br>
<br>
<span style="font-weight: bold;">EarleyRuleMap "HypMap"</span>: Each
EarleyRuleMap contains 'n' HypMap elements (in an array), one for each
hypothesis used by the Rule. These HypMaps differ from EarleyRuleMaps
only in that during processing a HypMap may be generated that does not
end up in the final ParseTree for its parent EarleyRuleMap. This is a
result of the fact that a Completed Item is found to be "completed" at
the end of an expression sub-sequence and its associated items in the
previous Completed Item Set are comingled with other completed items --
some of which do not end up in any ParseTree, but are simply
by-products of the Earley Parse algorithm and the Grammar itself.
So...to build an EarleyRuleMap there is a process of deductive
elimination, or "detective work", which is required to find the
EarleyRuleMap's hypotheses' completed items. <br>
<br>
However, once an EarleyRuleMap is successfully constructed, each HypMap
is itself a valid EarleyRuleMap in its own right -- and that means that
it covers a subsequence of the input expr just as the top level
EarleyRuleMap covers the entire expr. And it means that there can be
layers and layers below; some of those lower level EarleyRuleMaps may
even have twins! That is because a given subsequence of an expr with a
"parse sub-tree", may have more than one equivalent parsing -- if the
grammar is ambiguous. <br>
<br>
<span style="font-weight: bold;">EarleyRuleMap Data Structure</span> "-1 version" -- which is subsequently revised for efficiency: <br>
<br>
<code>public class EarleyRuleMap {<br>
&nbsp;&nbsp;&nbsp; /**<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; item - index into completedItemSet[exprThru] of EarleyItem<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; that maps from a GrammarRule to a portion of an<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; expression being parsed:<br>
&nbsp;&nbsp;&nbsp;&nbsp; *<br>
&nbsp;&nbsp;&nbsp;&nbsp;
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rule = completedItemSet[exprThru][itemIndex].rule;<br>
&nbsp;&nbsp;&nbsp;&nbsp; */<br>
&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itemIndex;<br>
<br>
&nbsp;&nbsp;&nbsp; /*<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; typ&nbsp; - typ code from EarleyItem.rule, here for convenience<br>
&nbsp;&nbsp;&nbsp;&nbsp; */<br>
&nbsp;&nbsp;&nbsp; Cnst&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typ;<br>
<br>
&nbsp;&nbsp;&nbsp; /**<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; exprFrom - index location of start of parameter in the<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; expression being parsed.<br>
&nbsp;&nbsp;&nbsp;&nbsp; */<br>
&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exprFrom;<br>
<br>
&nbsp;&nbsp;&nbsp; /**<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; thru - index location of end of parameter in the<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; expression being parsed.<br>
&nbsp;&nbsp;&nbsp;&nbsp; */<br>
&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exprThru;<br>
<br>
&nbsp;&nbsp;&nbsp; /**<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; hypMap -- array of EarleyRuleMaps, one element for each<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hypothesis of the GrammarRule.<br>
&nbsp;&nbsp;&nbsp;&nbsp; */<br>
&nbsp;&nbsp;&nbsp; EarleyRuleMap[] hypMap;<br>
<br>
&nbsp;&nbsp;&nbsp; /**<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; parseNodeHolder -- if not null, used instead of rule <br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to generate the output ParseTree. Example: a<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VarHyp in the input expr (there are no GrammarRules<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for variable hypotheses, these are "pre-parsed".)<br>
&nbsp;&nbsp;&nbsp;&nbsp; */<br>
&nbsp;&nbsp;&nbsp; ParseNodeHolder parseNodeHolder;<br>
<br>
</code><code>&nbsp;&nbsp;&nbsp; /**<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; twinFwd -- pointer reference to "twin" EarleyRuleMap <br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for a given subsequence of the input expr.<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Each twin will result in an additional output<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ParseTree. <br>&nbsp;&nbsp;&nbsp;&nbsp; */<br>
&nbsp;&nbsp;&nbsp; EarleyRuleMap twinFwd;<br>
</code><br>
<code>&nbsp;&nbsp;&nbsp; /**<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; twinBwd -- pointer reference to "twin" EarleyRuleMap <br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for a given subsequence of the input expr.<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NOT SURE A BACKWARD POINTER IS NEEDED.<br>&nbsp;&nbsp;&nbsp;&nbsp; */<br>
&nbsp;&nbsp;&nbsp; EarleyRuleMap twinBwd;<br>
</code><br>
<code><br>
&nbsp;&nbsp;&nbsp; public EarleyRuleMapping() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itemIndex = -1;<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
</code>Note that this structure can contain a condensed set of data for
multiple ParseTrees, but it does not solve the problem of exactly how
to generate the multiple trees. A brute force method for generating 'n'
top-level trees is to keep track of which tree we're working on,
TwinTree[0], TwinTree[1], TwinTree[2], etc. and then traverse the
EarleyRuleMap structure 'n' times keeping track of how many twins have
been seen and "consumed" so far: when working on Twin[0] don't use any
twin data; when working on Twin[1], use only the first twin reference,
etc. -- and that gets very awkward.<br>
<br>
The other humongous problem with this structure is that it is merely an
intermediate structure between the Earley Completed Itemsets and Parse
Trees -- which are themselves a byproduct used to generate RPN's for
Stmt's! This structure, so carefully built consumes the maximum amount
of space and still does not deliver an easy way to generate the
ParseTrees.&nbsp; It is however instructive of the main issue: once we
have an EarleyRuleMap we are guaranteed to have a Parse Tree, but there
can be many sets of HypMaps that can "fit" the EarleyRuleMap. The key
to the problem is to immediately generate a root ParseNode from the
EarleyRuleMap and then if there are alternative sets of VarHyps, to
iterate through those one-by-one, adding new "twin" root ParseNodes to
the EarleyRuleMap. This approach treats an EarleyRuleMap as a
disposable item whose contents are used and disposed of, except for the
chain of rootParseNodes -- which are the essential output. The work of
assembling the chain of root ParseNodes is performed by the
EarleyRuleMap object based on the sets of HypMaps for the rule. The
chain of root ParseNodes is then used by the next higher level
EarleyRuleMap to perform the same process, until finally, the top
EarleyRuleMap for the top rule contains a chain of root ParseNodes,
each corresponding to a ParseTree. So we save space and we minimize the
complications of traversing the set of EarleyRuleMaps by building the
ParseNodes as the EarleyRuleMaps are built; we don't need to store the
whole forest of them, just use them temporarily and discard them once
we have the needed ParseNodes!<br>
<br>
As a sidenote, the EarleyRuleMap class can be embedded in the
EarleyTreeBuilder class. This provides access to variables in the outer
class and hides the EarleyRuleMap (since it is totally custom for
EarleyTreeBuilder).<br>
<br>
<br>
<span style="font-weight: bold;">EarleyRuleMap Data Structure</span> "Version 0" -- the ultimate :)<br>

<br>

<code>public class EarleyRuleMap {<br>
&nbsp;&nbsp;&nbsp; /**<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; item - index into completedItemSet[exprThru] of EarleyItem<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; that maps from a GrammarRule to a portion of an<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; expression being parsed:<br>
&nbsp;&nbsp;&nbsp;&nbsp; *<br>
&nbsp;&nbsp;&nbsp;&nbsp;
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
rule = completedItemSet[exprThru][itemIndex].rule;<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A value of '-1' indicates search of Completed Item<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set should proceed from the beginning at the thru<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set,<br>
&nbsp; &nbsp;&nbsp; * &nbsp; &nbsp; <br>
&nbsp; &nbsp;&nbsp; * &nbsp; &nbsp; &nbsp; &nbsp; A value of '-2' indicates that the search has already <br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; been (totally) performed and nothing more should or <br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; can be done.<br>
&nbsp;&nbsp;&nbsp;&nbsp; */<br>
&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itemIndex;<br>
<br>
&nbsp;&nbsp;&nbsp; /*<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; typ&nbsp; - typ code from EarleyItem.rule, here for convenience<br>
&nbsp;&nbsp;&nbsp;&nbsp; */<br>
&nbsp;&nbsp;&nbsp; Cnst&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typ;<br>
<br>
&nbsp;&nbsp;&nbsp; /**<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; exprFrom - index location of start of parameter in the<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; expression being parsed.<br>
&nbsp;&nbsp;&nbsp;&nbsp; */<br>
&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exprFrom;<br>
<br>
&nbsp;&nbsp;&nbsp; /**<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; thru - index location of end of parameter in the<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; expression being parsed.<br>
&nbsp;&nbsp;&nbsp;&nbsp; */<br>
&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exprThru;<br>
<br>
&nbsp;&nbsp;&nbsp; /**<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; hypMap -- array of EarleyRuleMaps, one element for each<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hypothesis of the GrammarRule.<br>
&nbsp;&nbsp;&nbsp;&nbsp; */<br>
&nbsp;&nbsp;&nbsp; EarleyRuleMap[] hypMap;<br>
<br>
&nbsp;&nbsp;&nbsp; /**<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; parseNodeHolder -- after full loading of EarleyRuleMap<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; contains reference to ParseNodeHolder of root <br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; of parse tree for the rule map. The ParseNodeHolder<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; contains "fwd" and "bwd" references forming a<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; twin chain that enables multiple parse trees<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to be generated (for ambiguous grammar parses).<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Note that a hypMap can contain a parseNodeHolder<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to just a VarHyp with no corresponding rule<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from EarleyParse in the Completed ItemSet; this<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is because only NotationRules are input directly <br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to the parser, with NullsPermitted and TypeConversion<br>
&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rules being "pre-parsed" into the input expr.<br>

&nbsp;&nbsp;&nbsp;&nbsp; */<br>
&nbsp;&nbsp;&nbsp; ParseNodeHolder parseNodeHolder;<br>
}</code><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br><big><span style="font-weight: bold;">
Algorithm</span></big>:
The implementation's efficiency may be impacted
significantly by the need to search for multiple parse trees within the
Completed ItemSets. Therefore, we might consider using two functions:
the first, the fast one, is called to find at most one parse tree, and
the second is called if parseTreeArray.length &gt; 1. These functions
may share some code and be similar in many respects, so here is a
(draft) description of the first. The top level call uses <code>searchTyp = startRuleTyp</code>, <code>exprThru = expr.length - 1</code> and <code>exprFrom = 1</code>.<br>
<br>
<span style="font-weight: bold;">Variation 1 -- single tree<br>
<br>
<code>protected ParseNode buildOneParseNodeRootAtMost(<br>
</code><code>&nbsp;&nbsp;&nbsp; Cnst&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; searchTyp,<br>
</code></span>
<code><span style="font-weight: bold;">&nbsp; &nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exprFrom,<br>
&nbsp; &nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exprThru) {}</span><span style="font-weight: bold;"><br>
</span><big style="font-weight: bold;"></big></code><br>
<big style="font-weight: bold;"><code>1</code></big>. Search <code>pCompletedItem[exprThru]</code> backward, starting at <code>[pCompletedItemSetCnt[exprThru] - 1]</code>,&nbsp; through item 1 looking for an <code>EarleyItem</code>, "<code>x</code>" with <code>x.rule.getGrammarRuleTyp() == searchTyp</code>. If no item is found, return null, there are no parse trees. On the other hand, if such an <code>x</code> is found, then that means we <span style="font-style: italic;">do</span> have a parse tree available, and if the remainder of the code fails to produce a parse tree then <code>IllegalStateException</code> should be thrown because there is a bug.)<br>
<br>
<code><big><span style="font-weight: bold;">2</span></big></code>. call "<code>produceRuleParamArrayFromExpr(x.rule, exprFrom, exprThru)</code>" which builds <code>x.rule.getNbrHypParamsUsed()</code> <code>ParseNode</code>s from the <code>pCompletedItem[][]</code> arrays, one <code>ParseNode</code> for each variable hypothesis required by the <code>GrammarRule</code>, <code>x.rule</code>. These <code>ParseNode</code>s should be returned in an array of <code>ParseNodeHolder</code>s we will call, "<code>paramArray</code>" (note that each parseNodeHolder.parseNode may be the root of an extensive sub-tree!). <br>
<br>
<span style="font-weight: bold;">3</span><code style="font-weight: bold;"></code>. return <code>x.rule.buildGrammaticalParseNode(paramArray));<br>
</code><big><code style="font-weight: bold;"></code></big><br>
<hr style="width: 100%; height: 2px;"><br>
<code><span style="font-weight: bold;">protected ParseNodeHolder[] produceOneRuleParamArrayFromExpr(<br>
&nbsp;&nbsp;&nbsp; GrammarRule rule,<br>
&nbsp; &nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exprFrom,<br>
&nbsp; &nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exprThru) {}</span></code><span style="font-weight: bold;"><br>
</span>(assume <code>ParseNodeHolder[] expr</code> is in global storage)<br>
<br>
<span style="font-weight: bold;"></span><span style="font-style: italic; font-weight: bold;">Context/Overview:</span><br>
<br>
1. exprFrom and exprThru are passed because this function is used for
lower level nodes as well as the top level, so we may be pulling a
paramArray from just a portion of expr.<br>
<br>
2. x.rule.getRuleFormatExpr() returns a Cnst[] we'll call "ruleExpr".
An example from set.mm is axiom "wb" with ruleExpr = "( wff &lt;-&gt;
wff )", a Cnst[5] array. <br>
<br>
3. ruleExpr is the template we overlay upon expr[exprFrom] through
expr[exprThru] to find the variable hypothesis parameters for item x. <br>
<br>
4. ruleExpr.length may be less than <span style="font-style: italic;">or</span>
equal to [1 + exprThru - exprFrom], but if it is greater than -- or if
for any other reason we cannot derive paramArray, we should return null
to the caller -- he must have passed us the wrong rule to work with!<br>
<br>
5. In example from <a href="file:///C:/astevel3/mmj2/EarleyParseFunctionAlgorithm.html">file:///C:/astevel3/mmj2/EarleyParseFunctionAlgorithm.html</a>,
notice how the two wff parameters in ruleExpr must be produced from
their corresponding parts in the parse expr -- the "wff" to "wff" and
"wff" to "set = class". The problem is that we do not know which
portion of expr is overlaid by each wff parameter in ruleExpr!&nbsp;<code><span style="font-weight: bold;"></span></code>
<ul>
  <li>top parse rule (x) in completed item set 7, atIndex=1<span style="font-family: monospace;">, ruleExpr=</span><code> "( wff &lt;-&gt; wff )"</code></li>
  <li><code>Expr (in rule format)="</code><code>( wff&nbsp; &lt;-&gt;&nbsp; set = class )</code><code>"</code></li>
</ul>
To solve this problem we have to work right-to-left in ruleExpr and use
detective work to fight out the mappings. And, as can be seen, once we
have determined the mappings to use (i.e. ruleExpr wff #2 maps to
expr[4] through expr[6]) we can then make the recursive call to <br>
<code style="font-weight: bold;">&nbsp;&nbsp;&nbsp; buildOneParseNodeRootAtMost(mapTyp[i], mapFrom[i], mapThru[i]);<br>
</code><code><span style="font-weight: bold;"><br>
</span><span style="font-style: italic;">Note: the case of wff#1 is
illustrative of the problem our EarleyParser poses, as opposed to Dick
Grune's parser. We have already pre-parsed variables to their
corresponding variable hypotheses. That means that the mapping for wff
#1 in the example above will not have a rule to match to in Completed
ItemSet. However, we will know that mapFrom[i] = mapThru[i] and we can
just go directly to expr[i] to obtain the parseNode, which will have
typ == wff (if it doesn't then our detective screwed up or he needs to
keep searching.)</span><br style="font-style: italic;">
<span style="font-weight: bold;"><br>
</span></code>So, we do all this for each parameter in ruleExpr,
loading the returned ParseNodes into our ParseNodeHolder paramArray,
and voila!<br>
<code><span style="font-weight: bold;"><br>
</span></code>6. <code></code>Also, if <code>x.rule.getNbrHypParamsUsed()= 0</code>,
then we can just return a length=0 paramArray -- there cannot be any
substitutions to make except those implicit in GrammarRule x and its
paramTransformationTree (which hides the details of Nulls and Type
Conversions). <br>
<br>
<span style="font-weight: bold;"></span><br>
<br>
<code><br>
<span style="font-weight: bold;"><br>
<br>
<br>
</span><br>
<br>
</code>
<code></code><code><br>
</code>
<br>
</body></html>